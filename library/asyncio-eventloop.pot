# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-08-01 14:56+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../cpython/Doc/library/asyncio-eventloop.rst:6
msgid "Base Event Loop"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:8
msgid "**Source code:** :source:`Lib/asyncio/events.py`"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:10
msgid "The event loop is the central execution device provided by :mod:`asyncio`. It provides multiple facilities, including:"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:13
msgid "Registering, executing and cancelling delayed calls (timeouts)."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:15
msgid "Creating client and server :ref:`transports <asyncio-transport>` for various kinds of communication."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:18
msgid "Launching subprocesses and the associated :ref:`transports <asyncio-transport>` for communication with an external program."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:21
msgid "Delegating costly function calls to a pool of threads."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:25
msgid "This class is an implementation detail.  It is a subclass of :class:`AbstractEventLoop` and may be a base class of concrete event loop implementations found in :mod:`asyncio`.  It should not be used directly; use :class:`AbstractEventLoop` instead. ``BaseEventLoop`` should not be subclassed by third-party code; the internal interface is not stable."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:34
msgid "Abstract base class of event loops."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:36
msgid "This class is :ref:`not thread safe <asyncio-multithreading>`."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:39
msgid "Run an event loop"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:43
msgid "Run until :meth:`stop` is called.  If :meth:`stop` is called before :meth:`run_forever()` is called, this polls the I/O selector once with a timeout of zero, runs all callbacks scheduled in response to I/O events (and those that were already scheduled), and then exits. If :meth:`stop` is called while :meth:`run_forever` is running, this will run the current batch of callbacks and then exit.  Note that callbacks scheduled by callbacks will not run in that case; they will run the next time :meth:`run_forever` is called."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:56
msgid "Run until the :class:`Future` is done."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:58
msgid "If the argument is a :ref:`coroutine object <coroutine>`, it is wrapped by :func:`ensure_future`."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:61
msgid "Return the Future's result, or raise its exception."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:65
msgid "Returns running status of event loop."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:69
msgid "Stop running the event loop."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:71
msgid "This causes :meth:`run_forever` to exit at the next suitable opportunity (see there for more details)."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:78
msgid "Returns ``True`` if the event loop was closed."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:84
msgid "Close the event loop. The loop must not be running.  Pending callbacks will be lost."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:87
msgid "This clears the queues and shuts down the executor, but does not wait for the executor to finish."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:90
msgid "This is idempotent and irreversible. No other methods should be called after this one."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:96
msgid "Schedule all currently open :term:`asynchronous generator` objects to close with an :meth:`~agen.aclose()` call.  After calling this method, the event loop will issue a warning whenever a new asynchronous generator is iterated.  Should be used to finalize all scheduled asynchronous generators reliably.  Example::"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:114
msgid "Calls"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:116
msgid "Most :mod:`asyncio` functions don't accept keywords. If you want to pass keywords to your callback, use :func:`functools.partial`. For example, ``loop.call_soon(functools.partial(print, \"Hello\", flush=True))`` will call ``print(\"Hello\", flush=True)``."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:122
msgid ":func:`functools.partial` is better than ``lambda`` functions, because :mod:`asyncio` can inspect :func:`functools.partial` object to display parameters in debug mode, whereas ``lambda`` functions have a poor representation."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:129
msgid "Arrange for a callback to be called as soon as possible.  The callback is called after :meth:`call_soon` returns, when control returns to the event loop."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:133
msgid "This operates as a :abbr:`FIFO (first-in, first-out)` queue, callbacks are called in the order in which they are registered.  Each callback will be called exactly once."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:137
msgid "Any positional arguments after the callback will be passed to the callback when it is called."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:140
#: ../cpython/Doc/library/asyncio-eventloop.rst:193
msgid "An optional keyword-only *context* argument allows specifying a custom :class:`contextvars.Context` for the *callback* to run in.  The current context is used when no *context* is provided."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:144
msgid "An instance of :class:`asyncio.Handle` is returned, which can be used to cancel the callback."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:147
#: ../cpython/Doc/library/asyncio-eventloop.rst:197
#: ../cpython/Doc/library/asyncio-eventloop.rst:215
#: ../cpython/Doc/library/asyncio-eventloop.rst:645
#: ../cpython/Doc/library/asyncio-eventloop.rst:657
#: ../cpython/Doc/library/asyncio-eventloop.rst:863
msgid ":ref:`Use functools.partial to pass keywords to the callback <asyncio-pass-keywords>`."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:150
#: ../cpython/Doc/library/asyncio-eventloop.rst:161
#: ../cpython/Doc/library/asyncio-eventloop.rst:200
#: ../cpython/Doc/library/asyncio-eventloop.rst:218
msgid "The *context* keyword-only parameter was added. See :pep:`567` for more details."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:156
msgid "Like :meth:`call_soon`, but thread safe."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:158
msgid "See the :ref:`concurrency and multithreading <asyncio-multithreading>` section of the documentation."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:169
msgid "Delayed calls"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:171
msgid "The event loop has its own internal clock for computing timeouts. Which clock is used depends on the (platform-specific) event loop implementation; ideally it is a monotonic clock.  This will generally be a different clock than :func:`time.time`."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:179
msgid "Arrange for the *callback* to be called after the given *delay* seconds (either an int or float)."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:182
#: ../cpython/Doc/library/asyncio-eventloop.rst:212
msgid "An instance of :class:`asyncio.TimerHandle` is returned, which can be used to cancel the callback."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:185
msgid "*callback* will be called exactly once per call to :meth:`call_later`. If two callbacks are scheduled for exactly the same time, it is undefined which will be called first."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:189
msgid "The optional positional *args* will be passed to the callback when it is called. If you want the callback to be called with some named arguments, use a closure or :func:`functools.partial`."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:206
msgid "Arrange for the *callback* to be called at the given absolute timestamp *when* (an int or float), using the same time reference as :meth:`AbstractEventLoop.time`."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:210
msgid "This method's behavior is the same as :meth:`call_later`."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:224
msgid "Return the current time, as a :class:`float` value, according to the event loop's internal clock."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:229
msgid "The :func:`asyncio.sleep` function."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:233
msgid "Futures"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:237
msgid "Create an :class:`asyncio.Future` object attached to the loop."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:239
msgid "This is a preferred way to create futures in asyncio, as event loop implementations can provide alternative implementations of the Future class (with better performance or instrumentation)."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:247
msgid "Tasks"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:251
msgid "Schedule the execution of a :ref:`coroutine object <coroutine>`: wrap it in a future. Return a :class:`Task` object."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:254
msgid "Third-party event loops can use their own subclass of :class:`Task` for interoperability. In this case, the result type is a subclass of :class:`Task`."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:262
msgid "Set a task factory that will be used by :meth:`AbstractEventLoop.create_task`."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:265
msgid "If *factory* is ``None`` the default task factory will be set."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:267
msgid "If *factory* is a *callable*, it should have a signature matching ``(loop, coro)``, where *loop* will be a reference to the active event loop, *coro* will be a coroutine object.  The callable must return an :class:`asyncio.Future` compatible object."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:276
msgid "Return a task factory, or ``None`` if the default one is in use."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:282
msgid "Creating connections"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:286
msgid "Create a streaming transport connection to a given Internet *host* and *port*: socket family :py:data:`~socket.AF_INET` or :py:data:`~socket.AF_INET6` depending on *host* (or *family* if specified), socket type :py:data:`~socket.SOCK_STREAM`.  *protocol_factory* must be a callable returning a :ref:`protocol <asyncio-protocol>` instance."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:292
#: ../cpython/Doc/library/asyncio-eventloop.rst:374
#: ../cpython/Doc/library/asyncio-eventloop.rst:427
msgid "This method will try to establish the connection in the background. When successful, it returns a ``(transport, protocol)`` pair."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:295
msgid "The chronological synopsis of the underlying operation is as follows:"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:297
msgid "The connection is established, and a :ref:`transport <asyncio-transport>` is created to represent it."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:300
msgid "*protocol_factory* is called without arguments and must return a :ref:`protocol <asyncio-protocol>` instance."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:303
msgid "The protocol instance is tied to the transport, and its :meth:`connection_made` method is called."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:306
msgid "The coroutine returns successfully with the ``(transport, protocol)`` pair."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:309
msgid "The created transport is an implementation-dependent bidirectional stream."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:312
msgid "*protocol_factory* can be any kind of callable, not necessarily a class.  For example, if you want to use a pre-created protocol instance, you can pass ``lambda: my_protocol``."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:316
msgid "Options that change how the connection is created:"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:318
msgid "*ssl*: if given and not false, a SSL/TLS transport is created (by default a plain TCP transport is created).  If *ssl* is a :class:`ssl.SSLContext` object, this context is used to create the transport; if *ssl* is :const:`True`, a context with some unspecified default settings is used."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:324
msgid ":ref:`SSL/TLS security considerations <ssl-security>`"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:326
msgid "*server_hostname*, is only for use together with *ssl*, and sets or overrides the hostname that the target server's certificate will be matched against.  By default the value of the *host* argument is used.  If *host* is empty, there is no default and you must pass a value for *server_hostname*.  If *server_hostname* is an empty string, hostname matching is disabled (which is a serious security risk, allowing for man-in-the-middle-attacks)."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:334
msgid "*family*, *proto*, *flags* are the optional address family, protocol and flags to be passed through to getaddrinfo() for *host* resolution. If given, these should all be integers from the corresponding :mod:`socket` module constants."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:339
msgid "*sock*, if given, should be an existing, already connected :class:`socket.socket` object to be used by the transport. If *sock* is given, none of *host*, *port*, *family*, *proto*, *flags* and *local_addr* should be specified."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:344
msgid "*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to bind the socket to locally.  The *local_host* and *local_port* are looked up using getaddrinfo(), similarly to *host* and *port*."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:348
#: ../cpython/Doc/library/asyncio-eventloop.rst:556
#: ../cpython/Doc/library/asyncio-eventloop.rst:625
msgid "*ssl_handshake_timeout* is (for an SSL connection) the time in seconds to wait for the SSL handshake to complete before aborting the connection. ``60.0`` seconds if ``None`` (default)."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:354
#: ../cpython/Doc/library/asyncio-eventloop.rst:440
#: ../cpython/Doc/library/asyncio-eventloop.rst:564
msgid "The *ssl_handshake_timeout* parameter."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:358
#: ../cpython/Doc/library/asyncio-eventloop.rst:510
msgid "On Windows with :class:`ProactorEventLoop`, SSL/TLS is now supported."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:362
msgid "The :func:`open_connection` function can be used to get a pair of (:class:`StreamReader`, :class:`StreamWriter`) instead of a protocol."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:368
msgid "Create datagram connection: socket family :py:data:`~socket.AF_INET`, :py:data:`~socket.AF_INET6` or :py:data:`~socket.AF_UNIX` depending on *host* (or *family* if specified), socket type :py:data:`~socket.SOCK_DGRAM`. *protocol_factory* must be a callable returning a :ref:`protocol <asyncio-protocol>` instance."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:377
msgid "Options changing how the connection is created:"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:379
msgid "*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to bind the socket to locally.  The *local_host* and *local_port* are looked up using :meth:`getaddrinfo`."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:383
msgid "*remote_addr*, if given, is a ``(remote_host, remote_port)`` tuple used to connect the socket to a remote address.  The *remote_host* and *remote_port* are looked up using :meth:`getaddrinfo`."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:387
msgid "*family*, *proto*, *flags* are the optional address family, protocol and flags to be passed through to :meth:`getaddrinfo` for *host* resolution. If given, these should all be integers from the corresponding :mod:`socket` module constants."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:392
#: ../cpython/Doc/library/asyncio-eventloop.rst:484
msgid "*reuse_address* tells the kernel to reuse a local socket in TIME_WAIT state, without waiting for its natural timeout to expire. If not specified will automatically be set to ``True`` on UNIX."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:397
msgid "*reuse_port* tells the kernel to allow this endpoint to be bound to the same port as other existing endpoints are bound to, so long as they all set this flag when being created. This option is not supported on Windows and some UNIX's. If the :py:data:`~socket.SO_REUSEPORT` constant is not defined then this capability is unsupported."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:403
msgid "*allow_broadcast* tells the kernel to allow this endpoint to send messages to the broadcast address."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:406
msgid "*sock* can optionally be specified in order to use a preexisting, already connected, :class:`socket.socket` object to be used by the transport. If specified, *local_addr* and *remote_addr* should be omitted (must be :const:`None`)."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:411
msgid "On Windows with :class:`ProactorEventLoop`, this method is not supported."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:413
msgid "See :ref:`UDP echo client protocol <asyncio-udp-echo-client-protocol>` and :ref:`UDP echo server protocol <asyncio-udp-echo-server-protocol>` examples."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:416
msgid "The *family*, *proto*, *flags*, *reuse_address*, *reuse_port, *allow_broadcast*, and *sock* parameters were added."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:422
msgid "Create UNIX connection: socket family :py:data:`~socket.AF_UNIX`, socket type :py:data:`~socket.SOCK_STREAM`. The :py:data:`~socket.AF_UNIX` socket family is used to communicate between processes on the same machine efficiently."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:430
#: ../cpython/Doc/library/asyncio-eventloop.rst:527
msgid "*path* is the name of a UNIX domain socket, and is required unless a *sock* parameter is specified.  Abstract UNIX sockets, :class:`str`, :class:`bytes`, and :class:`~pathlib.Path` paths are supported."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:434
msgid "See the :meth:`AbstractEventLoop.create_connection` method for parameters."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:436
#: ../cpython/Doc/library/asyncio-eventloop.rst:531
msgid "Availability: UNIX."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:444
msgid "The *path* parameter can now be a :term:`path-like object`."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:448
msgid "Creating listening connections"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:452
msgid "Create a TCP server (socket type :data:`~socket.SOCK_STREAM`) bound to *host* and *port*."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:455
msgid "Return a :class:`Server` object, its :attr:`~Server.sockets` attribute contains created sockets. Use the :meth:`Server.close` method to stop the server: close listening sockets."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:459
#: ../cpython/Doc/library/asyncio-eventloop.rst:548
#: ../cpython/Doc/library/asyncio-eventloop.rst:611
msgid "Parameters:"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:461
msgid "The *host* parameter can be a string, in that case the TCP server is bound to *host* and *port*. The *host* parameter can also be a sequence of strings and in that case the TCP server is bound to all hosts of the sequence. If *host* is an empty string or ``None``, all interfaces are assumed and a list of multiple sockets will be returned (most likely one for IPv4 and another one for IPv6)."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:468
msgid "*family* can be set to either :data:`socket.AF_INET` or :data:`~socket.AF_INET6` to force the socket to use IPv4 or IPv6. If not set it will be determined from host (defaults to :data:`socket.AF_UNSPEC`)."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:472
msgid "*flags* is a bitmask for :meth:`getaddrinfo`."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:474
msgid "*sock* can optionally be specified in order to use a preexisting socket object. If specified, *host* and *port* should be omitted (must be :const:`None`)."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:478
msgid "*backlog* is the maximum number of queued connections passed to :meth:`~socket.socket.listen` (defaults to 100)."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:481
#: ../cpython/Doc/library/asyncio-eventloop.rst:553
msgid "*ssl* can be set to an :class:`~ssl.SSLContext` to enable SSL over the accepted connections."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:489
msgid "*reuse_port* tells the kernel to allow this endpoint to be bound to the same port as other existing endpoints are bound to, so long as they all set this flag when being created. This option is not supported on Windows."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:494
msgid "*ssl_handshake_timeout* is (for an SSL server) the time in seconds to wait for the SSL handshake to complete before aborting the connection. ``60.0`` seconds if ``None`` (default)."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:498
msgid "*start_serving* set to ``True`` (the default) causes the created server to start accepting connections immediately.  When set to ``False``, the user should await on :meth:`Server.start_serving` or :meth:`Server.serve_forever` to make the server to start accepting connections."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:506
msgid "*ssl_handshake_timeout* and *start_serving* parameters."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:514
msgid "The function :func:`start_server` creates a (:class:`StreamReader`, :class:`StreamWriter`) pair and calls back a function with this pair."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:519
msgid "The *host* parameter can now be a sequence of strings."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:524
msgid "Similar to :meth:`AbstractEventLoop.create_server`, but specific to the socket family :py:data:`~socket.AF_UNIX`."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:535
msgid "The *ssl_handshake_timeout* and *start_serving* parameters."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:539
msgid "The *path* parameter can now be a :class:`~pathlib.Path` object."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:543
msgid "Handle an accepted connection."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:545
msgid "This is used by servers that accept connections outside of asyncio but that use asyncio to handle them."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:550
msgid "*sock* is a preexisting socket object returned from an ``accept`` call."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:560
msgid "When completed it returns a ``(transport, protocol)`` pair."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:570
msgid "File Transferring"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:576
msgid "Send a *file* to *transport*, return the total number of bytes which were sent."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:579
msgid "The method uses high-performance :meth:`os.sendfile` if available."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:581
#: ../cpython/Doc/library/asyncio-eventloop.rst:776
msgid "*file* must be a regular file object opened in binary mode."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:583
#: ../cpython/Doc/library/asyncio-eventloop.rst:778
msgid "*offset* tells from where to start reading the file. If specified, *count* is the total number of bytes to transmit as opposed to sending the file until EOF is reached. File position is updated on return or also in case of error in which case :meth:`file.tell() <io.IOBase.tell>` can be used to figure out the number of bytes which were sent."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:590
#: ../cpython/Doc/library/asyncio-eventloop.rst:785
msgid "*fallback* set to ``True`` makes asyncio to manually read and send the file when the platform does not support the sendfile syscall (e.g. Windows or SSL socket on Unix)."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:594
#: ../cpython/Doc/library/asyncio-eventloop.rst:789
msgid "Raise :exc:`SendfileNotAvailableError` if the system does not support *sendfile* syscall and *fallback* is ``False``."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:601
msgid "TLS Upgrade"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:605
msgid "Upgrades an existing connection to TLS."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:607
msgid "Returns a new transport instance, that the *protocol* must start using immediately after the *await*.  The *transport* instance passed to the *start_tls* method should never be used again."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:613
msgid "*transport* and *protocol* instances that methods like :meth:`~AbstractEventLoop.create_server` and :meth:`~AbstractEventLoop.create_connection` return."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:617
msgid "*sslcontext*: a configured instance of :class:`~ssl.SSLContext`."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:619
msgid "*server_side* pass ``True`` when a server-side connection is being upgraded (like the one created by :meth:`~AbstractEventLoop.create_server`)."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:622
msgid "*server_hostname*: sets or overrides the host name that the target server's certificate will be matched against."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:633
msgid "Watch file descriptors"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:635
msgid "On Windows with :class:`SelectorEventLoop`, only socket handles are supported (ex: pipe file descriptors are not supported)."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:638
msgid "On Windows with :class:`ProactorEventLoop`, these methods are not supported."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:642
msgid "Start watching the file descriptor for read availability and then call the *callback* with specified arguments."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:650
msgid "Stop watching the file descriptor for read availability."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:654
msgid "Start watching the file descriptor for write availability and then call the *callback* with specified arguments."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:662
msgid "Stop watching the file descriptor for write availability."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:664
msgid "The :ref:`watch a file descriptor for read events <asyncio-watch-read-event>` example uses the low-level :meth:`AbstractEventLoop.add_reader` method to register the file descriptor of a socket."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:670
msgid "Low-level socket operations"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:674
msgid "Receive data from the socket.  Modeled after blocking :meth:`socket.socket.recv` method."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:677
msgid "The return value is a bytes object representing the data received.  The maximum amount of data to be received at once is specified by *nbytes*."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:681
#: ../cpython/Doc/library/asyncio-eventloop.rst:697
#: ../cpython/Doc/library/asyncio-eventloop.rst:713
#: ../cpython/Doc/library/asyncio-eventloop.rst:726
msgid "With :class:`SelectorEventLoop` event loop, the socket *sock* must be non-blocking."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:684
#: ../cpython/Doc/library/asyncio-eventloop.rst:755
msgid "Even though the method was always documented as a coroutine method, before Python 3.7 it returned a :class:`Future`. Since Python 3.7, this is an ``async def`` method."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:691
msgid "Receive data from the socket.  Modeled after blocking :meth:`socket.socket.recv_into` method."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:694
msgid "The received data is written into *buf* (a writable buffer). The return value is the number of bytes written."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:704
msgid "Send data to the socket.  Modeled after blocking :meth:`socket.socket.sendall` method."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:707
msgid "The socket must be connected to a remote socket. This method continues to send data from *data* until either all data has been sent or an error occurs.  ``None`` is returned on success.  On error, an exception is raised, and there is no way to determine how much data, if any, was successfully processed by the receiving end of the connection."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:716
msgid "Even though the method was always documented as a coroutine method, before Python 3.7 it returned an :class:`Future`. Since Python 3.7, this is an ``async def`` method."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:723
msgid "Connect to a remote socket at *address*.  Modeled after blocking :meth:`socket.socket.connect` method."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:729
msgid "``address`` no longer needs to be resolved.  ``sock_connect`` will try to check if the *address* is already resolved by calling :func:`socket.inet_pton`.  If not, :meth:`AbstractEventLoop.getaddrinfo` will be used to resolve the *address*."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:738
msgid ":meth:`AbstractEventLoop.create_connection` and  :func:`asyncio.open_connection() <open_connection>`."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:744
msgid "Accept a connection.  Modeled after blocking :meth:`socket.socket.accept`."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:747
msgid "The socket must be bound to an address and listening for connections. The return value is a pair ``(conn, address)`` where *conn* is a *new* socket object usable to send and receive data on the connection, and *address* is the address bound to the socket on the other end of the connection."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:753
msgid "The socket *sock* must be non-blocking."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:762
msgid ":meth:`AbstractEventLoop.create_server` and :func:`start_server`."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:768
msgid "Send a file using high-performance :mod:`os.sendfile` if possible and return the total number of bytes which were sent."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:771
msgid "Asynchronous version of :meth:`socket.socket.sendfile`."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:773
msgid "*sock* must be non-blocking :class:`~socket.socket` of :const:`socket.SOCK_STREAM` type."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:796
msgid "Resolve host name"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:800
msgid "This method is a :ref:`coroutine <coroutine>`, similar to :meth:`socket.getaddrinfo` function but non-blocking."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:805
msgid "This method is a :ref:`coroutine <coroutine>`, similar to :meth:`socket.getnameinfo` function but non-blocking."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:808
msgid "Both *getaddrinfo* and *getnameinfo* methods were always documented to return a coroutine, but prior to Python 3.7 they were, in fact, returning :class:`asyncio.Future` objects.  Starting with Python 3.7 both methods are coroutines."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:816
msgid "Connect pipes"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:818
msgid "On Windows with :class:`SelectorEventLoop`, these methods are not supported. Use :class:`ProactorEventLoop` to support pipes on Windows."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:823
msgid "Register read pipe in eventloop."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:825
msgid "*protocol_factory* should instantiate object with :class:`Protocol` interface.  *pipe* is a :term:`file-like object <file object>`. Return pair ``(transport, protocol)``, where *transport* supports the :class:`ReadTransport` interface."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:830
#: ../cpython/Doc/library/asyncio-eventloop.rst:842
msgid "With :class:`SelectorEventLoop` event loop, the *pipe* is set to non-blocking mode."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:835
msgid "Register write pipe in eventloop."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:837
msgid "*protocol_factory* should instantiate object with :class:`BaseProtocol` interface. *pipe* is :term:`file-like object <file object>`. Return pair ``(transport, protocol)``, where *transport* supports :class:`WriteTransport` interface."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:847
msgid "The :meth:`AbstractEventLoop.subprocess_exec` and :meth:`AbstractEventLoop.subprocess_shell` methods."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:852
msgid "UNIX signals"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:854
msgid "Availability: UNIX only."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:858
msgid "Add a handler for a signal."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:860
msgid "Raise :exc:`ValueError` if the signal number is invalid or uncatchable. Raise :exc:`RuntimeError` if there is a problem setting up the handler."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:868
msgid "Remove a handler for a signal."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:870
msgid "Return ``True`` if a signal handler was removed, ``False`` if not."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:874
msgid "The :mod:`signal` module."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:878
msgid "Executor"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:880
msgid "Call a function in an :class:`~concurrent.futures.Executor` (pool of threads or pool of processes). By default, an event loop uses a thread pool executor (:class:`~concurrent.futures.ThreadPoolExecutor`)."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:886
msgid "Arrange for a *func* to be called in the specified executor."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:888
msgid "The *executor* argument should be an :class:`~concurrent.futures.Executor` instance. The default executor is used if *executor* is ``None``."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:891
msgid ":ref:`Use functools.partial to pass keywords to the *func* <asyncio-pass-keywords>`."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:894
msgid "This method returns a :class:`asyncio.Future` object."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:896
msgid ":meth:`BaseEventLoop.run_in_executor` no longer configures the ``max_workers`` of the thread pool executor it creates, instead leaving it up to the thread pool executor (:class:`~concurrent.futures.ThreadPoolExecutor`) to set the default."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:905
msgid "Set *executor* as the default executor used by :meth:`run_in_executor`. *executor* should be an instance of :class:`~concurrent.futures.ThreadPoolExecutor`."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:909
msgid "Using an executor that is not an instance of :class:`~concurrent.futures.ThreadPoolExecutor` is deprecated and will trigger an error in Python 3.9."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:916
msgid "Error Handling API"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:918
msgid "Allows customizing how exceptions are handled in the event loop."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:922
msgid "Set *handler* as the new event loop exception handler."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:924
msgid "If *handler* is ``None``, the default exception handler will be set."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:927
msgid "If *handler* is a callable object, it should have a matching signature to ``(loop, context)``, where ``loop`` will be a reference to the active event loop, ``context`` will be a ``dict`` object (see :meth:`call_exception_handler` documentation for details about context)."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:935
msgid "Return the exception handler, or ``None`` if the default one is in use."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:942
msgid "Default exception handler."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:944
msgid "This is called when an exception occurs and no exception handler is set, and can be called by a custom exception handler that wants to defer to the default behavior."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:948
msgid "*context* parameter has the same meaning as in :meth:`call_exception_handler`."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:953
msgid "Call the current event loop exception handler."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:955
msgid "*context* is a ``dict`` object containing the following keys (new keys may be introduced later):"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:958
msgid "'message': Error message;"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:959
msgid "'exception' (optional): Exception object;"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:960
msgid "'future' (optional): :class:`asyncio.Future` instance;"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:961
msgid "'handle' (optional): :class:`asyncio.Handle` instance;"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:962
msgid "'protocol' (optional): :ref:`Protocol <asyncio-protocol>` instance;"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:963
msgid "'transport' (optional): :ref:`Transport <asyncio-transport>` instance;"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:964
msgid "'socket' (optional): :class:`socket.socket` instance."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:968
msgid "Note: this method should not be overloaded in subclassed event loops.  For any custom exception handling, use :meth:`set_exception_handler()` method."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:973
msgid "Debug mode"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:977
msgid "Get the debug mode (:class:`bool`) of the event loop."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:979
msgid "The default value is ``True`` if the environment variable :envvar:`PYTHONASYNCIODEBUG` is set to a non-empty string, ``False`` otherwise."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:987
msgid "Set the debug mode of the event loop."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:993
msgid "The :ref:`debug mode of asyncio <asyncio-debug-mode>`."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:996
msgid "Server"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1000
msgid "Server listening on sockets."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1002
msgid "Object created by :meth:`AbstractEventLoop.create_server`, :meth:`AbstractEventLoop.create_unix_server`, :func:`start_server`, and :func:`start_unix_server` functions.  Don't instantiate the class directly."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1007
msgid "*Server* objects are asynchronous context managers.  When used in an ``async with`` statement, it's guaranteed that the Server object is closed and not accepting new connections when the ``async with`` statement is completed::"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1020
msgid "Server object is an asynchronous context manager since Python 3.7."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1025
msgid "Stop serving: close listening sockets and set the :attr:`sockets` attribute to ``None``."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1028
msgid "The sockets that represent existing incoming client connections are left open."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1031
msgid "The server is closed asynchronously, use the :meth:`wait_closed` coroutine to wait until the server is closed."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1036
msgid "Gives the event loop associated with the server object."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1042
msgid "Start accepting connections."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1044
msgid "This method is idempotent, so it can be called when the server is already being serving."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1047
msgid "The new *start_serving* keyword-only parameter to :meth:`AbstractEventLoop.create_server` and :meth:`asyncio.start_server` allows to create a Server object that is not accepting connections right away.  In which case this method, or :meth:`Server.serve_forever` can be used to make the Server object to start accepting connections."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1058
msgid "Start accepting connections until the coroutine is cancelled. Cancellation of ``serve_forever`` task causes the server to be closed."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1062
msgid "This method can be called if the server is already accepting connections.  Only one ``serve_forever`` task can exist per one *Server* object."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1066
msgid "Example::"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1084
msgid "Return ``True`` if the server is accepting new connections."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1090
msgid "Wait until the :meth:`close` method completes."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1094
msgid "List of :class:`socket.socket` objects the server is listening to, or ``None`` if the server is closed."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1097
msgid "Prior to Python 3.7 ``Server.sockets`` used to return the internal list of server's sockets directly.  In 3.7 a copy of that list is returned."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1104
msgid "Handle"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1108
msgid "A callback wrapper object returned by :func:`AbstractEventLoop.call_soon`, :func:`AbstractEventLoop.call_soon_threadsafe`."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1113
msgid "Cancel the call.  If the callback is already canceled or executed, this method has no effect."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1118
msgid "Return ``True`` if the call was cancelled."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1124
msgid "A callback wrapper object returned by :func:`AbstractEventLoop.call_later`, and :func:`AbstractEventLoop.call_at`."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1127
msgid "The class is inherited from :class:`Handle`."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1131
msgid "Return a scheduled callback time as :class:`float` seconds."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1133
msgid "The time is an absolute timestamp, using the same time reference as :meth:`AbstractEventLoop.time`."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1140
msgid "SendfileNotAvailableError"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1145
msgid "Sendfile syscall is not available, subclass of :exc:`RuntimeError`."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1147
msgid "Raised if the OS does not support sendfile syscall for given socket or file type."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1152
msgid "Event loop examples"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1157
msgid "Hello World with call_soon()"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1159
msgid "Example using the :meth:`AbstractEventLoop.call_soon` method to schedule a callback. The callback displays ``\"Hello World\"`` and then stops the event loop::"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1180
msgid "The :ref:`Hello World coroutine <asyncio-hello-world-coroutine>` example uses a :ref:`coroutine <coroutine>`."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1187
msgid "Display the current date with call_later()"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1189
msgid "Example of callback displaying the current date every second. The callback uses the :meth:`AbstractEventLoop.call_later` method to reschedule itself during 5 seconds, and then stops the event loop::"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1215
msgid "The :ref:`coroutine displaying the current date <asyncio-date-coroutine>` example uses a :ref:`coroutine <coroutine>`."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1223
msgid "Watch a file descriptor for read events"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1225
msgid "Wait until a file descriptor received some data using the :meth:`AbstractEventLoop.add_reader` method and then close the event loop::"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1259
msgid "The :ref:`register an open socket to wait for data using a protocol <asyncio-register-socket>` example uses a low-level protocol created by the :meth:`AbstractEventLoop.create_connection` method."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1263
msgid "The :ref:`register an open socket to wait for data using streams <asyncio-register-socket-streams>` example uses high-level streams created by the :func:`open_connection` function in a coroutine."
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1269
msgid "Set signal handlers for SIGINT and SIGTERM"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1271
msgid "Register handlers for signals :py:data:`SIGINT` and :py:data:`SIGTERM` using the :meth:`AbstractEventLoop.add_signal_handler` method::"
msgstr ""

#: ../cpython/Doc/library/asyncio-eventloop.rst:1295
msgid "This example only works on UNIX."
msgstr ""

